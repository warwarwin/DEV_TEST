"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodedJwtOrZid = exports.searchRegisteredDestination = exports.registerDestination = exports.registerDestinationCache = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const jwt_1 = require("../jwt");
const environment_accessor_1 = require("../environment-accessor");
const destination_cache_1 = require("./destination-cache");
const http_proxy_util_1 = require("./http-proxy-util");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'register-destination'
});
/**
 * @internal
 */
exports.registerDestinationCache = (0, destination_cache_1.DestinationCache)(new destination_cache_1.DefaultDestinationCache(undefined));
/**
 * Registers a destination in a cache for later usage.
 *
 * If a destination with the same key is already in the cache, it is replaced.
 * The key is built using the `getDestinationCacheKey` method.
 * @param destination - A destination to add to the `destinations` cache.
 * @param options - Options how to cache the destination.
 */
async function registerDestination(destination, options) {
    if (!destination.name || !destination.url) {
        throw Error('Registering destinations requires a destination name and url.');
    }
    await exports.registerDestinationCache.cacheRetrievedDestination(decodedJwtOrZid(options), destination, isolationStrategy(options));
}
exports.registerDestination = registerDestination;
/**
 * @internal
 * @param options - The options for searching the cahce
 * @returns Destination - the destination from cache
 */
async function searchRegisteredDestination(options) {
    let decodedJwt;
    // An error will be thrown if no jwt and no xsuaa service exist.
    try {
        decodedJwt = decodedJwtOrZid(options);
    }
    catch (e) {
        logger.debug('Failed to retrieve registered destination, because it was neither possible to decode jwt nor create a dummy jwt with `zid` property.');
        logger.debug(e);
        return null;
    }
    const destination = (await exports.registerDestinationCache.retrieveDestinationFromCache(decodedJwt, options.destinationName, isolationStrategy(options))) || null;
    if (destination === null || destination === void 0 ? void 0 : destination.forwardAuthToken) {
        destination.authTokens = destinationAuthToken(options.jwt);
    }
    if (destination) {
        logger.info(`Successfully retrieved destination '${options.destinationName}' from registered destinations.`);
    }
    else {
        logger.debug(`Could not retrieve '${options.destinationName}' from registered destinations.`);
    }
    return destination &&
        ((0, http_proxy_util_1.proxyStrategy)(destination) === http_proxy_util_1.ProxyStrategy.INTERNET_PROXY ||
            (0, http_proxy_util_1.proxyStrategy)(destination) === http_proxy_util_1.ProxyStrategy.PRIVATELINK_PROXY)
        ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
}
exports.searchRegisteredDestination = searchRegisteredDestination;
/**
 * If a explicit isolation strategy is given by the user this is used. If not the isolation strategy is determined in the following way:
 * If a JWT is given and it contains a user_id the isolation is 'TenantUser'. If no JWT is given or it does not contian a user the isolation is 'Tenant'.
 * @param options - Options passed to register the destination containing the jwt.
 * @returns The isolation strategy.
 */
function isolationStrategy(options) {
    if (options === null || options === void 0 ? void 0 : options.isolationStrategy) {
        return options.isolationStrategy;
    }
    const decoded = (options === null || options === void 0 ? void 0 : options.jwt) ? (0, jwt_1.decodeJwt)(options.jwt) : undefined;
    return (0, destination_cache_1.getDefaultIsolationStrategy)(decoded);
}
/**
 * This method either decodes the given JWT. If the JWT is not given it will use the subdomain if the XSUAA and create a Object with zid this subdomain.
 * This is then passed on to build the cache key.
 * @param options - Options passed to register the destination containing the jwt.
 * @returns The decoded JWT or a dummy JWT containing the tenant identifier (zid).
 * @internal
 */
function decodedJwtOrZid(options) {
    if (options === null || options === void 0 ? void 0 : options.jwt) {
        return (0, jwt_1.decodeJwt)(options.jwt);
    }
    const providerTenantId = (0, environment_accessor_1.getXsuaaServiceCredentials)(options === null || options === void 0 ? void 0 : options.jwt).subaccountid;
    return { zid: providerTenantId };
}
exports.decodedJwtOrZid = decodedJwtOrZid;
function destinationAuthToken(token) {
    if (token) {
        const decoded = (0, jwt_1.decodeJwt)(token);
        logger.debug("Option 'forwardAuthToken' enabled on destination. Using the initial token for the destination.");
        return [
            {
                value: token,
                expiresIn: decoded.exp.toString(),
                error: null,
                http_header: { key: 'Authorization', value: `Bearer ${token}` },
                type: 'Bearer'
            }
        ];
    }
    logger.warn("Option 'forwardAuthToken' was set on destination but no token was provided to forward. This is most likely unintended and will lead to a authorization error on request execution.");
}
//# sourceMappingURL=destination-from-registration.js.map