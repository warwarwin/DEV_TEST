"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DestinationFromServiceRetriever = exports.getDestinationFromDestinationService = exports.getDestinationServiceCredentials = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const jwt_1 = require("../jwt");
const token_accessor_1 = require("../token-accessor");
const connectivity_service_1 = require("../connectivity-service");
const environment_accessor_1 = require("../environment-accessor");
const tenant_1 = require("../tenant");
const identity_service_1 = require("../identity-service");
const xsuaa_service_1 = require("../xsuaa-service");
const destination_selection_strategies_1 = require("./destination-selection-strategies");
const destination_service_1 = require("./destination-service");
const destination_cache_1 = require("./destination-cache");
const http_proxy_util_1 = require("./http-proxy-util");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'destination-accessor-service'
});
const emptyDestinationByType = {
    instance: [],
    subaccount: []
};
/**
 * Utility function to get destination service credentails, including error handling.
 * @internal
 */
function getDestinationServiceCredentials() {
    const credentials = (0, environment_accessor_1.getDestinationServiceCredentialsList)();
    if (!credentials || credentials.length === 0) {
        throw Error('No binding to a destination service instance found. Please bind a destination service instance to your application.');
    }
    if (credentials.length > 1) {
        logger.warn('Found more than one destination service instance. Using the first one.');
    }
    return credentials[0];
}
exports.getDestinationServiceCredentials = getDestinationServiceCredentials;
/**
 * Retrieves a destination with the given name from the Cloud Foundry destination service.
 * Returns `null`, if no destination can be found.
 * Requires the following service bindings: destination, XSUAA
 * By default, selects subscriber over provider and instance over subaccount destinations.
 * @param options - Configuration for how to retrieve destinations from the destination service.
 * @returns A promise returning the requested destination on success.
 */
async function getDestinationFromDestinationService(options) {
    logger.debug('Attempting to retrieve destination from destination service.');
    return DestinationFromServiceRetriever.getDestinationFromDestinationService(options);
}
exports.getDestinationFromDestinationService = getDestinationFromDestinationService;
/**
 * @internal
 */
class DestinationFromServiceRetriever {
    static async getDestinationFromDestinationService(options) {
        if ((0, identity_service_1.isTokenExchangeEnabled)(options)) {
            options.jwt = await (0, identity_service_1.exchangeToken)(options);
        }
        const subscriberToken = await DestinationFromServiceRetriever.getSubscriberToken(options);
        const providerToken = await DestinationFromServiceRetriever.getProviderServiceToken(options);
        const da = new DestinationFromServiceRetriever(options, subscriberToken, providerToken);
        const destinationResult = await da.searchDestinationWithSelectionStrategyAndCache();
        if (!destinationResult) {
            return null;
        }
        if (destinationResult.fromCache) {
            return destinationResult.destination;
        }
        let { destination } = destinationResult;
        if (destination.authentication === 'OAuth2UserTokenExchange' ||
            destination.authentication === 'OAuth2JWTBearer' ||
            destination.authentication === 'SAMLAssertion' ||
            (destination.authentication === 'OAuth2SAMLBearerAssertion' &&
                !da.usesSystemUser(destination))) {
            destination = await da.fetchDestinationWithUserExchangeFlows(destinationResult);
        }
        if (destination.authentication === 'PrincipalPropagation') {
            if (!this.isUserJwt(da.subscriberToken)) {
                DestinationFromServiceRetriever.throwUserTokenMissing(destination);
            }
        }
        if (destination.authentication === 'OAuth2Password' ||
            destination.authentication === 'ClientCertificateAuthentication' ||
            destination.authentication === 'OAuth2ClientCredentials' ||
            da.usesSystemUser(destination)) {
            destination = await da.fetchDestinationWithNonUserExchangeFlows(destinationResult);
        }
        const withProxySetting = await da.addProxyConfiguration(destination);
        const withTrustStore = await da.addTrustStoreConfiguration(withProxySetting, destinationResult.origin);
        await da.updateDestinationCache(withTrustStore, destinationResult.origin);
        return withTrustStore;
    }
    static async getSubscriberToken(options) {
        if (options.jwt) {
            if (options.iss) {
                logger.warn('You have provided the `userJwt` and `iss` options to fetch the destination. This is most likely unintentional. Ignoring `iss`.');
            }
            if ((0, jwt_1.isXsuaaToken)((0, jwt_1.decodeJwtComplete)(options.jwt))) {
                await (0, jwt_1.verifyJwt)(options.jwt, options);
                const serviceJwtEncoded = await (0, token_accessor_1.serviceToken)('destination', {
                    ...options,
                    jwt: options.jwt
                });
                return {
                    type: 'xsuaa',
                    userJwt: (0, jwt_1.getJwtPair)(options.jwt),
                    serviceJwt: (0, jwt_1.getJwtPair)(serviceJwtEncoded)
                };
            }
            return {
                type: 'custom',
                userJwt: (0, jwt_1.getJwtPair)(options.jwt),
                serviceJwt: undefined
            };
        }
        if (options.iss) {
            logger.debug('Using `iss` option to fetch a destination instead of a full JWT. No validation is performed.');
            const serviceJwtEncoded = await (0, token_accessor_1.serviceToken)('destination', {
                ...options,
                jwt: { iss: options.iss }
            });
            return {
                type: 'iss',
                userJwt: undefined,
                serviceJwt: (0, jwt_1.getJwtPair)(serviceJwtEncoded)
            };
        }
    }
    static async getProviderServiceToken(options) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { jwt, ...optionsWithoutJwt } = options;
        const encoded = await (0, token_accessor_1.serviceToken)('destination', {
            ...optionsWithoutJwt
        });
        return { encoded, decoded: (0, jwt_1.decodeJwt)(encoded) };
    }
    static throwUserTokenMissing(destination) {
        throw Error(`No user token (JWT) has been provided. This is strictly necessary for '${destination.authentication}'.`);
    }
    static checkDestinationForCustomJwt(destination) {
        if (!destination.jwks && !destination.jwksUri) {
            throw new Error('Failed to verify the JWT with no JKU! Destination must have `x_user_token.jwks` or `x_user_token.jwks_uri` property.');
        }
    }
    static isUserJwt(token) {
        return !!token && token.type !== 'iss';
    }
    constructor(options, subscriberToken, providerServiceToken) {
        var _a;
        this.subscriberToken = subscriberToken;
        this.providerServiceToken = providerServiceToken;
        const defaultOptions = {
            isolationStrategy: (0, destination_cache_1.getDefaultIsolationStrategy)((_a = subscriberToken === null || subscriberToken === void 0 ? void 0 : subscriberToken.userJwt) === null || _a === void 0 ? void 0 : _a.decoded),
            selectionStrategy: destination_selection_strategies_1.subscriberFirst,
            useCache: !!options.isolationStrategy
        };
        this.options = { ...defaultOptions, ...options };
    }
    async searchDestinationWithSelectionStrategyAndCache() {
        let destinationSearchResult;
        if (this.isSubscriberNeeded()) {
            destinationSearchResult =
                await this.searchSubscriberAccountForDestination();
        }
        if (this.isProviderNeeded(destinationSearchResult)) {
            destinationSearchResult =
                await this.searchProviderAccountForDestination();
        }
        if (destinationSearchResult && !destinationSearchResult.fromCache) {
            logger.debug('Successfully retrieved destination from destination service.');
        }
        if (destinationSearchResult && destinationSearchResult.fromCache) {
            logger.debug(`Successfully retrieved destination from destination service cache for ${destinationSearchResult.origin} destinations.`);
        }
        if (!destinationSearchResult) {
            logger.debug('Could not retrieve destination from destination service.');
        }
        return destinationSearchResult;
    }
    async getInstanceAndSubaccountDestinations(accessToken) {
        const [instance, subaccount] = await Promise.all([
            (0, destination_service_1.fetchInstanceDestinations)(getDestinationServiceCredentials().uri, accessToken, this.options),
            (0, destination_service_1.fetchSubaccountDestinations)(getDestinationServiceCredentials().uri, accessToken, this.options)
        ]);
        return {
            instance,
            subaccount
        };
    }
    async fetchDestinationByToken(jwt) {
        return (0, destination_service_1.fetchDestination)(getDestinationServiceCredentials().uri, jwt, this.options);
    }
    getExchangeTenant(destination) {
        var _a, _b, _c;
        if (destination.authentication !== 'OAuth2ClientCredentials') {
            return undefined;
        }
        if (destination.originalProperties['tokenServiceURLType'] !== 'Common') {
            return undefined;
        }
        const subdomainSubscriber = (0, xsuaa_service_1.getSubdomainAndZoneId)((_b = (_a = this.subscriberToken) === null || _a === void 0 ? void 0 : _a.userJwt) === null || _b === void 0 ? void 0 : _b.encoded).subdomain;
        const subdomainProvider = (0, xsuaa_service_1.getSubdomainAndZoneId)((_c = this.providerServiceToken) === null || _c === void 0 ? void 0 : _c.encoded).subdomain;
        return subdomainSubscriber || subdomainProvider || undefined;
    }
    async getAuthTokenForOAuth2ClientCrendentials(destinationResult) {
        const { destination, origin } = destinationResult;
        // This covers the X-Tenant case https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
        const exchangeTenant = this.getExchangeTenant(destination);
        const clientGrant = await (0, token_accessor_1.serviceToken)('destination', {
            jwt: origin === 'provider'
                ? this.providerServiceToken.decoded
                : this.subscriberToken.serviceJwt.decoded
        });
        return { authHeaderJwt: clientGrant, exchangeTenant };
    }
    // This covers the two technical user propagation https://help.sap.com/viewer/cca91383641e40ffbe03bdc78f00f681/Cloud/en-US/3cb7b81115c44cf594e0e3631291af94.html
    usesSystemUser(destination) {
        // put this in the non user dependent block
        if (destination.systemUser &&
            destination.authentication === 'OAuth2SAMLBearerAssertion') {
            logger.debug(`System user found on destination: "${destination.name}". 
The property SystemUser has been deprecated. 
It is highly recommended that you stop using it.
Possible alternatives for such technical user authentication are BasicAuthentication, OAuth2ClientCredentials, or ClientCertificateAuthentication`);
            return true;
        }
        return false;
    }
    async getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult) {
        const { destination, origin } = destinationResult;
        const { destinationName } = this.options;
        if (!DestinationFromServiceRetriever.isUserJwt(this.subscriberToken)) {
            throw DestinationFromServiceRetriever.throwUserTokenMissing(destination);
        }
        // This covers OAuth to user dependend auth flows https://help.sap.com/viewer/cca91383641e40ffbe03bdc78f00f681/Cloud/en-US/39d42654093e4f8db20398a06f7eab2b.html and https://api.sap.com/api/SAP_CP_CF_Connectivity_Destination/resource
        // Which is the same for: OAuth2UserTokenExchange, OAuth2JWTBearer and OAuth2SAMLBearerAssertion
        // If user JWT is not XSUAA enforce the JWKS properties are there - destination service would do that as wll. https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/d81e1683bd434823abf3ceefc4ff157f.html
        if (this.subscriberToken.type === 'custom') {
            DestinationFromServiceRetriever.checkDestinationForCustomJwt(destination);
        }
        // Case 1 Destination in provider and jwt issued for provider account But not custom JWT given-> not extra x-user-token header needed
        if (this.subscriberToken.type !== 'custom' &&
            (0, tenant_1.isIdenticalTenant)(this.subscriberToken.userJwt.decoded, this.providerServiceToken.decoded)) {
            logger.debug(`UserExchange flow started without user exchange token for destination ${destinationName} of the provider account.`);
            return {
                authHeaderJwt: await (0, token_accessor_1.jwtBearerToken)(this.subscriberToken.userJwt.encoded, (0, environment_accessor_1.getDestinationService)(), this.options)
            };
        }
        // Case 2 Subscriber and provider account not the same OR custom jwt -> x-user-token  header passed to determine user and tenant in token service URL and service token to get the destination
        const serviceJwt = origin === 'provider'
            ? this.providerServiceToken
            : this.subscriberToken.serviceJwt;
        logger.debug(`UserExchange flow started for destination ${destinationName} of the ${origin} account.`);
        return {
            authHeaderJwt: serviceJwt.encoded,
            exchangeHeaderJwt: this.subscriberToken.userJwt.encoded // token considered for user and tenant
        };
    }
    /**
     * @internal
     * This method calls the 'find destination by name' endpoint of the destination service using a client credentials grant.
     * For the find by name endpoint, the destination service will take care of OAuth flows and include the token in the destination.
     * @param destinationResult - Result of the getDestinations call for which the exchange flow is triggred
     * @returns Destination containing the auth token.
     */
    async fetchDestinationWithNonUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2ClientCrendentials(destinationResult);
        return this.fetchDestinationByToken(token);
    }
    async fetchDestinationWithUserExchangeFlows(destinationResult) {
        const token = await this.getAuthTokenForOAuth2UserBasedTokenExchanges(destinationResult);
        return this.fetchDestinationByToken(token);
    }
    async addProxyConfiguration(destination) {
        var _a, _b;
        switch ((0, http_proxy_util_1.proxyStrategy)(destination)) {
            case http_proxy_util_1.ProxyStrategy.ON_PREMISE_PROXY:
                return (0, connectivity_service_1.addProxyConfigurationOnPrem)(destination, ((_a = this.subscriberToken) === null || _a === void 0 ? void 0 : _a.type) === 'iss'
                    ? this.subscriberToken.serviceJwt
                    : (_b = this.subscriberToken) === null || _b === void 0 ? void 0 : _b.userJwt);
            case http_proxy_util_1.ProxyStrategy.INTERNET_PROXY:
            case http_proxy_util_1.ProxyStrategy.PRIVATELINK_PROXY:
                return (0, http_proxy_util_1.addProxyConfigurationInternet)(destination);
            case http_proxy_util_1.ProxyStrategy.NO_PROXY:
                return destination;
            default:
                throw new Error('Illegal argument: No valid proxy configuration found in the destination input to be added.');
        }
    }
    selectSubscriberJwt() {
        if (!this.subscriberToken) {
            throw new Error('Try to get subscriber token but value is undefined.');
        }
        switch (this.subscriberToken.type) {
            case 'custom':
                return this.subscriberToken.userJwt.decoded;
            case 'iss':
                return this.subscriberToken.serviceJwt.decoded;
            case 'xsuaa':
                return this.subscriberToken.userJwt.decoded;
        }
    }
    async updateDestinationCache(destination, destinationOrigin) {
        if (!this.options.useCache) {
            return destination;
        }
        await destination_cache_1.destinationCache.cacheRetrievedDestination(destinationOrigin === 'subscriber'
            ? this.selectSubscriberJwt()
            : this.providerServiceToken.decoded, destination, this.options.isolationStrategy);
    }
    async getProviderDestinationService() {
        const provider = await this.getInstanceAndSubaccountDestinations(this.providerServiceToken.encoded);
        const destination = this.options.selectionStrategy({
            subscriber: emptyDestinationByType,
            provider
        }, this.options.destinationName);
        if (destination) {
            return {
                destination,
                fromCache: false,
                origin: 'provider'
            };
        }
    }
    async getProviderDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache(this.providerServiceToken.decoded, this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
            return { destination, fromCache: true, origin: 'subscriber' };
        }
    }
    async getSubscriberDestinationService() {
        if (!this.subscriberToken || this.subscriberToken.type === 'custom') {
            throw new Error('Try to get destinations from subscriber account but user JWT was not set.');
        }
        const subscriber = await this.getInstanceAndSubaccountDestinations(this.subscriberToken.serviceJwt.encoded);
        const destination = this.options.selectionStrategy({
            subscriber,
            provider: emptyDestinationByType
        }, this.options.destinationName);
        if (destination) {
            return { destination, fromCache: false, origin: 'subscriber' };
        }
    }
    async getSubscriberDestinationCache() {
        const destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache(this.selectSubscriberJwt(), this.options.destinationName, this.options.isolationStrategy);
        if (destination) {
            return { destination, fromCache: true, origin: 'subscriber' };
        }
    }
    isProviderNeeded(resultFromSubscriber) {
        if (this.options.selectionStrategy === destination_selection_strategies_1.alwaysSubscriber) {
            return false;
        }
        if (this.options.selectionStrategy === destination_selection_strategies_1.subscriberFirst &&
            resultFromSubscriber) {
            return false;
        }
        return true;
    }
    isSubscriberNeeded() {
        if (!this.subscriberToken) {
            return false;
        }
        if (this.subscriberToken.type === 'custom') {
            return false;
        }
        if (this.options.selectionStrategy === destination_selection_strategies_1.alwaysProvider) {
            return false;
        }
        return true;
    }
    async searchProviderAccountForDestination() {
        return ((this.options.useCache && (await this.getProviderDestinationCache())) ||
            this.getProviderDestinationService());
    }
    async searchSubscriberAccountForDestination() {
        return ((this.options.useCache && (await this.getSubscriberDestinationCache())) ||
            this.getSubscriberDestinationService());
    }
    async addTrustStoreConfiguration(destination, origin) {
        var _a;
        if ((_a = destination.originalProperties) === null || _a === void 0 ? void 0 : _a.TrustStoreLocation) {
            const trustStoreCertificate = await (0, destination_service_1.fetchCertificate)(getDestinationServiceCredentials().uri, origin === 'provider'
                ? this.providerServiceToken.encoded
                : this.subscriberToken.serviceJwt.encoded, destination.originalProperties.TrustStoreLocation);
            destination.trustStoreCertificate = trustStoreCertificate;
        }
        return destination;
    }
}
exports.DestinationFromServiceRetriever = DestinationFromServiceRetriever;
//# sourceMappingURL=destination-from-service.js.map