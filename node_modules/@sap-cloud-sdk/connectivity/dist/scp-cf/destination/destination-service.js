"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchCertificate = exports.fetchDestination = exports.fetchSubaccountDestinations = exports.fetchInstanceDestinations = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const opossum_1 = __importDefault(require("opossum"));
const axios_1 = __importDefault(require("axios"));
const jwt_1 = require("../jwt");
const resilience_options_1 = require("../resilience-options");
const http_agent_1 = require("../../http-agent");
const destination_1 = require("./destination");
const destination_service_types_1 = require("./destination-service-types");
const destination_service_cache_1 = require("./destination-service-cache");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'destination-service'
});
let circuitBreaker;
/**
 * Fetches all instance destinations from the given URI.
 * @param destinationServiceUri - The URI of the destination service
 * @param jwt - The access token
 * @param options - Options to use by retrieving destinations
 * @returns A promise resolving to a list of instance destinations
 * @internal
 */
function fetchInstanceDestinations(destinationServiceUri, jwt, options) {
    return fetchDestinations(destinationServiceUri, jwt, destination_service_types_1.DestinationType.Instance, options);
}
exports.fetchInstanceDestinations = fetchInstanceDestinations;
/**
 * Fetches all subaccount destinations from the given URI.
 * @param destinationServiceUri - The URI of the destination service
 * @param jwt - The access token
 * @param options - Options to use by retrieving destinations
 * @returns A promise resolving to a list of subaccount destinations
 * @internal
 */
function fetchSubaccountDestinations(destinationServiceUri, jwt, options) {
    return fetchDestinations(destinationServiceUri, jwt, destination_service_types_1.DestinationType.Subaccount, options);
}
exports.fetchSubaccountDestinations = fetchSubaccountDestinations;
function isParsable(destinationResponse) {
    const config = (0, destination_1.getDestinationConfig)(destinationResponse);
    try {
        (0, destination_1.validateDestinationConfig)(config);
        return true;
    }
    catch (err) {
        logger.debug(`Parsing of destination with name "${config.Name}" failed - skip this destination in parsing.`);
        return false;
    }
}
async function fetchDestinations(destinationServiceUri, jwt, type, options) {
    const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/${type}Destinations`;
    if (options === null || options === void 0 ? void 0 : options.useCache) {
        const destinationsFromCache = destination_service_cache_1.destinationServiceCache.retrieveDestinationsFromCache(targetUri, (0, jwt_1.decodeJwt)(jwt));
        if (destinationsFromCache) {
            logger.debug(`Destinations retrieved from cache. There were ${destinationsFromCache.length} destinations returned from the cache.`);
            return destinationsFromCache;
        }
    }
    const headers = (0, jwt_1.wrapJwtInHeader)(jwt).headers;
    return callDestinationEndpoint(targetUri, headers, options)
        .then(response => {
        const destinations = response.data
            .filter(isParsable)
            .map(parsableDestination => (0, destination_1.parseDestination)(parsableDestination));
        if (options === null || options === void 0 ? void 0 : options.useCache) {
            destination_service_cache_1.destinationServiceCache.cacheRetrievedDestinations(targetUri, (0, jwt_1.decodeJwt)(jwt), destinations);
        }
        return destinations;
    })
        .catch(error => {
        throw new util_1.ErrorWithCause(`Failed to fetch ${type} destinations.${errorMessageFromResponse(error)}`, error);
    });
}
/**
 * Fetches a specific destination by name from the given URI, including authorization tokens.
 * For destinations with authenticationType OAuth2SAMLBearerAssertion, this call will trigger the OAuth2SAMLBearerFlow against the target destination.
 * In this pass the access token as string.
 * Fetches a specific destination with authenticationType OAuth2UserTokenExchange by name from the given URI, including authorization tokens.
 * @param destinationServiceUri - The URI of the destination service
 * @param token - The access token or AuthAndExchangeTokens if you want to include the X-user-token for OAuth2UserTokenExchange.
 * @param options - Options to use by retrieving destinations
 * @returns A Promise resolving to the destination
 * @internal
 */
async function fetchDestination(destinationServiceUri, token, options) {
    return fetchDestinationByTokens(destinationServiceUri, typeof token === 'string' ? { authHeaderJwt: token } : token, options);
}
exports.fetchDestination = fetchDestination;
/**
 * Fetches a certificate from the subaccount and destination instance for a given a name.
 * Subaccount is tried first.
 * @param destinationServiceUri - The URI of the destination service
 * @param token - The access token for destination service.
 * @param certificateName - Name of the Certificate to be fetched
 * @returns A Promise resolving to the destination
 * @internal
 */
async function fetchCertificate(destinationServiceUri, token, certificateName) {
    const filetype = certificateName.split('.')[1];
    if (filetype.toLowerCase() !== 'pem') {
        logger.warn(`The provided truststore ${certificateName} is not in 'pem' format which is currently the only supported format. Trustore is ignored.`);
        return;
    }
    const accountUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/subaccountCertificates/${certificateName}`;
    const instanceUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/instanceCertificates/${certificateName}`;
    const header = (0, jwt_1.wrapJwtInHeader)(token).headers;
    try {
        const response = await callCertificateEndpoint(accountUri, header).catch(() => callCertificateEndpoint(instanceUri, header));
        return (0, destination_1.parseCertificate)(response.data);
    }
    catch (err) {
        logger.warn(`Failed to fetch truststore certificate ${certificateName} - Continuing without certificate. This may cause failing requests`, err);
    }
}
exports.fetchCertificate = fetchCertificate;
async function fetchDestinationByTokens(destinationServiceUri, tokens, options) {
    const targetUri = `${(0, util_1.removeTrailingSlashes)(destinationServiceUri)}/destination-configuration/v1/destinations/${options.destinationName}`;
    let authHeader = (0, jwt_1.wrapJwtInHeader)(tokens.authHeaderJwt).headers;
    authHeader = tokens.exchangeHeaderJwt
        ? { ...authHeader, 'X-user-token': tokens.exchangeHeaderJwt }
        : authHeader;
    authHeader = tokens.exchangeTenant
        ? { ...authHeader, 'X-tenant': tokens.exchangeTenant }
        : authHeader;
    return callDestinationEndpoint(targetUri, authHeader, options)
        .then(response => {
        const destination = (0, destination_1.parseDestination)(response.data);
        return destination;
    })
        .catch(error => {
        {
            throw new util_1.ErrorWithCause(`Failed to fetch destination ${options.destinationName}.${errorMessageFromResponse(error)}`, error);
        }
    });
}
function errorMessageFromResponse(error) {
    return (0, util_1.propertyExists)(error, 'response', 'data', 'ErrorMessage')
        ? ` ${error.response.data.ErrorMessage}`
        : '';
}
async function callCertificateEndpoint(uri, headers, options) {
    if (!uri.includes('Certificates')) {
        throw new Error(`callCertificateEndpoint was called with illegal arrgument: ${uri}. URL must be certificate endpoint of destination service.`);
    }
    return callDestinationService(uri, headers, options);
}
async function callDestinationEndpoint(uri, headers, options) {
    if (!uri.match(/[instance|subaccount]Destinations|v1\/destinations/)) {
        throw new Error(`callDestinationEndpoint was called with illegal arrgument: ${uri}. URL must be destination(s) endpoint of destination service.`);
    }
    return callDestinationService(uri, headers, options);
}
async function callDestinationService(uri, headers, options) {
    const { enableCircuitBreaker, timeout } = {
        ...resilience_options_1.defaultResilienceBTPServices,
        ...options
    };
    const config = {
        ...(0, http_agent_1.urlAndAgent)(uri),
        proxy: false,
        method: 'get',
        timeout,
        headers
    };
    if (enableCircuitBreaker) {
        return getCircuitBreaker().fire(config);
    }
    return axios_1.default.request(config);
}
function getCircuitBreaker() {
    const request = axios_1.default.request;
    if (!circuitBreaker) {
        circuitBreaker = new opossum_1.default(request, resilience_options_1.circuitBreakerDefaultOptions);
    }
    return circuitBreaker;
}
//# sourceMappingURL=destination-service.js.map