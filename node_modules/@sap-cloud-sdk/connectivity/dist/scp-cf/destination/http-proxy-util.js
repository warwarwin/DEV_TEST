"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyStrategy = exports.proxyAgent = exports.addProxyConfigurationInternet = exports.parseProxyEnv = exports.proxyStrategy = void 0;
const url_1 = require("url");
const http_proxy_agent_1 = require("http-proxy-agent");
const https_proxy_agent_1 = require("https-proxy-agent");
const util_1 = require("@sap-cloud-sdk/util");
const protocol_1 = require("../protocol");
const authorization_header_1 = require("../authorization-header");
const get_protocol_1 = require("../get-protocol");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'proxy-util'
});
/**
 * Determines the proxy strategy. If noProxy is set the ProxyConfiguration in the destination is omitted.
 * For onPremProxy or internetProxy the connectivity service or environment variables are checked to fill the {@link ProxyConfiguration}.
 * @param destination - from which the proxy strategy is derived.
 * @returns ProxyStrategy possible values are noProxy, internetProxy or onPremProxy.
 * @internal
 */
function proxyStrategy(destination) {
    if (destination.proxyType === 'OnPremise') {
        logger.debug('OnPrem destination proxy settings from connectivity service will be used.');
        return ProxyStrategy.ON_PREMISE_PROXY;
    }
    if (destination.proxyType === 'PrivateLink') {
        logger.debug('PrivateLink destination proxy settings will be used. This is not supported in local/CI/CD environments.');
        return ProxyStrategy.PRIVATELINK_PROXY;
    }
    const destinationProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
    if (!getProxyEnvValue(destinationProtocol)) {
        logger.debug(`Could not find proxy settings for ${destinationProtocol} in the environment variables - no proxy used.`);
        return ProxyStrategy.NO_PROXY;
    }
    if (getNoProxyEnvValue().includes(destination.url)) {
        logger.debug(`Destination URL ${destination.url} is in no_proxy list: ${getNoProxyEnvValue()} - no proxy used.`);
        return ProxyStrategy.NO_PROXY;
    }
    if (getProxyEnvValue(destinationProtocol)) {
        logger.debug(`Proxy settings for ${destinationProtocol} are found in environment variables.`);
        return ProxyStrategy.INTERNET_PROXY;
    }
    return ProxyStrategy.NO_PROXY;
}
exports.proxyStrategy = proxyStrategy;
function getProxyEnvValue(protocol) {
    const proxyEnvKey = protocol + '_proxy';
    const proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] ||
        process.env[proxyEnvKey.toUpperCase()];
    logger.debug(`Tried to read ${proxyEnvKey.toLowerCase()} or ${proxyEnvKey.toUpperCase()} from the environment variables. Found value is ${proxyEnvValue}.`);
    if (!proxyEnvValue) {
        return undefined;
    }
    return proxyEnvValue;
}
function getNoProxyEnvValue() {
    const noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
    if (!noProxyEnv) {
        return [];
    }
    const split = noProxyEnv.split(',').map(s => s.trim());
    if (split.find(s => s.includes('*'))) {
        logger.warn(`The no_proxy env contains a wildcard ${noProxyEnv}, which is currently not supported`);
    }
    return split;
}
function getPort(url) {
    if (url.port) {
        return parseInt(url.port);
    }
    return url.protocol === 'https:' ? 443 : 80;
}
function getOriginalProtocol(href) {
    const test = href.match(/^[\w.-]+:\/\//);
    return test ? test[0].slice(0, -2) : undefined;
}
function sanitizeUrl(href) {
    const protocol = getOriginalProtocol(href);
    if (!protocol) {
        logger.debug('No protocol specified, using "http:".');
        return `http://${href}`;
    }
    return href;
}
function validateUrl(url) {
    if (url.protocol !== 'http:' && url.protocol !== 'https:') {
        throw new Error(`Unsupported protocol "${url.protocol}".`);
    }
    if (url.protocol === 'https:') {
        logger.debug('Using protocol "https:" to connect to a proxy. This is unusual but possible.');
    }
    if (url.username && !url.password) {
        throw new Error('Password missing.');
    }
}
/**
 * Parses the environment variable for the web proxy and extracts the values considering defaults like http for the protocol and 80 or 443 for the port.
 * The general pattern to be parsed is `protocol://user:password@host:port`, where everything besides the host is optional.
 * Special characters in the user and password need to be percent encoded.
 * @param proxyEnvValue - Environment variable which is parsed.
 * @returns Configuration with default values or `undefined` if the parsing failed.
 */
function parseProxyEnv(proxyEnvValue) {
    const href = sanitizeUrl(proxyEnvValue);
    try {
        const url = new url_1.URL(href);
        validateUrl(url);
        const proxyConfig = {
            host: url.hostname,
            protocol: (0, protocol_1.getProtocol)(url.protocol),
            port: getPort(url)
        };
        if (url.username && url.password) {
            proxyConfig.headers = {
                'Proxy-Authorization': (0, authorization_header_1.basicHeader)(decodeURIComponent(url.username), decodeURIComponent(url.password))
            };
        }
        if (proxyConfig) {
            const loggableConfig = {
                ...proxyConfig,
                headers: (0, util_1.sanitizeRecord)(proxyConfig.headers || {}, 'Authorization header present. Not logged for security reasons.')
            };
            logger.debug(`Used Proxy Configuration: ${JSON.stringify(loggableConfig, null, 2)}.`);
        }
        return proxyConfig;
    }
    catch (err) {
        logger.warn(`Could not parse proxy configuration from environment variable. Reason: ${err.message}`);
        return undefined;
    }
}
exports.parseProxyEnv = parseProxyEnv;
/**
 * Adds the proxy configuration to a destination based on web proxies defined in environment variables. See {@link ProxyConfiguration} and {@link proxyStrategy} for details.
 * @param destination - to which the proxy configuration is added.
 * @returns Destination containing the configuration for web proxy.
 * @internal
 */
function addProxyConfigurationInternet(destination) {
    const proxyEnvValue = getProxyEnvValue((0, get_protocol_1.getProtocolOrDefault)(destination));
    if (proxyEnvValue) {
        const proxyConfiguration = parseProxyEnv(proxyEnvValue);
        if (proxyConfiguration) {
            return { ...destination, proxyConfiguration };
        }
        return { ...destination };
    }
    logger.warn('Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.');
    return { ...destination };
}
exports.addProxyConfigurationInternet = addProxyConfigurationInternet;
/**
 * Builds the http(s)-agent config. Note that the proxy agent type like http or https is determined by the destination RUL protocol.
 * The protocol from the proxy is unrelated to this and in most cases http.
 * All additional options are forwarded to tls.connect and net.connect see https://github.com/TooTallNate/node-https-proxy-agent#new-httpsproxyagentobject-options
 * @param destination - Destination containing the proxy configurations
 * @param options - Additional options for the agent
 * @returns The http(s)-agent containing the proxy configuration
 * @internal
 */
function proxyAgent(destination, options) {
    const targetProtocol = (0, get_protocol_1.getProtocolOrDefault)(destination);
    const proxyConfig = destination.proxyConfiguration;
    if (!proxyConfig) {
        throw new Error('Proxy config must not be undefined.');
    }
    if (options === null || options === void 0 ? void 0 : options.host) {
        logger.warn(`The agent options you passed to the proxy agent creation contains the host "${options.host}" which will overwrite the host from the proxy config.`);
    }
    if (options === null || options === void 0 ? void 0 : options.port) {
        logger.warn(`The agent options you passed to the proxy agent creation contains the port "${options.port}" which will overwrite the port from the proxy config.`);
    }
    const agentConfig = {
        host: proxyConfig.host,
        protocol: proxyConfig.protocol,
        port: proxyConfig.port,
        ...options
    };
    switch (targetProtocol) {
        case protocol_1.Protocol.HTTP:
            return {
                httpAgent: new http_proxy_agent_1.HttpProxyAgent(agentConfig)
            };
        case protocol_1.Protocol.HTTPS:
            return {
                httpsAgent: new https_proxy_agent_1.HttpsProxyAgent(agentConfig)
            };
        default:
            throw new Error(`The target protocol: ${targetProtocol} has to be either http or https.`);
    }
}
exports.proxyAgent = proxyAgent;
/**
 * Enum representing the different strategies for proxies on requests. Possible situations are "NO_PROXY", use the connectivity service proxy for On-Premise connection or a usual web proxy.
 * See also {@link ProxyConfiguration} for more details.
 * @internal
 */
var ProxyStrategy;
(function (ProxyStrategy) {
    ProxyStrategy[ProxyStrategy["NO_PROXY"] = 0] = "NO_PROXY";
    ProxyStrategy[ProxyStrategy["ON_PREMISE_PROXY"] = 1] = "ON_PREMISE_PROXY";
    ProxyStrategy[ProxyStrategy["INTERNET_PROXY"] = 2] = "INTERNET_PROXY";
    ProxyStrategy[ProxyStrategy["PRIVATELINK_PROXY"] = 3] = "PRIVATELINK_PROXY";
})(ProxyStrategy = exports.ProxyStrategy || (exports.ProxyStrategy = {}));
//# sourceMappingURL=http-proxy-util.js.map