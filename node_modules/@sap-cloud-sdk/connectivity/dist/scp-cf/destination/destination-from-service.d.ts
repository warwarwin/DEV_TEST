import { JwtPair } from '../jwt';
import { DestinationServiceCredentials } from '../environment-accessor-types';
import { Destination } from './destination-service-types';
import { DestinationFetchOptions, DestinationOptions } from './destination-accessor-types';
/**
 * When a destination is fetched from the SDK the user can pass different tokens.
 * The token determines from which tenant the destination is obtained (provider or subscriber) and if it contains user information so that user propagation flows are possible.
 * Possible types are: A user specific JWT issued by the XSUAA, a JWT from a custom IdP or only the `iss` property to get destinations from a different tenant.
 * We name these tokens "subscriber tokens", because they are related to the subscriber account in contrast to the"provider account", where the application is running.
 * The tenant defined in the subscriber token is the provider tenant for single tenant applications.
 */
type SubscriberToken = IssToken | XsuaaToken | CustomToken;
/**
 * User provided a dummy token with the `iss` property.
 * This is used if a tenant other than the provider tenant should be accessed but no user related login (JWT) is available for this tenant.
 * Therefore, the `userJwt` is undefined and only a destination service token has been issued.
 */
interface IssToken {
    type: 'iss';
    userJwt: undefined;
    serviceJwt: JwtPair;
}
/**
 * User provided a token issued form the XSUAA.
 * This token has the JKU properties to be verified by the SDK.
 * The provided token is the userJwt containing the `zid` and `user_id` properties.
 * The service token was derived from this token and is for the same tenant.
 */
interface XsuaaToken {
    type: 'xsuaa';
    userJwt: JwtPair;
    serviceJwt: JwtPair;
}
/**
 * User provided a token from a custom issuer (not XSUAA).
 * Such a token can not be converted to a service token by the XSUAA.
 * Therefore, the serviceJwt is undefined and the SDK does not do a token validation - the destination service does this based on jwks properties on the destination.
 * For service calls the provider service token is used so this types works only for single tenant application.
 */
interface CustomToken {
    type: 'custom';
    userJwt: JwtPair;
    serviceJwt: undefined;
}
/**
 * Utility function to get destination service credentails, including error handling.
 * @internal
 */
export declare function getDestinationServiceCredentials(): DestinationServiceCredentials;
/**
 * Retrieves a destination with the given name from the Cloud Foundry destination service.
 * Returns `null`, if no destination can be found.
 * Requires the following service bindings: destination, XSUAA
 * By default, selects subscriber over provider and instance over subaccount destinations.
 * @param options - Configuration for how to retrieve destinations from the destination service.
 * @returns A promise returning the requested destination on success.
 */
export declare function getDestinationFromDestinationService(options: DestinationFetchOptions): Promise<Destination | null>;
/**
 * @internal
 */
export declare class DestinationFromServiceRetriever {
    readonly subscriberToken: SubscriberToken | undefined;
    readonly providerServiceToken: JwtPair;
    static getDestinationFromDestinationService(options: DestinationFetchOptions): Promise<Destination | null>;
    static getSubscriberToken(options: DestinationOptions): Promise<SubscriberToken | undefined>;
    static getProviderServiceToken(options: DestinationOptions): Promise<JwtPair>;
    private static throwUserTokenMissing;
    private static checkDestinationForCustomJwt;
    private static isUserJwt;
    private options;
    private constructor();
    private searchDestinationWithSelectionStrategyAndCache;
    private getInstanceAndSubaccountDestinations;
    private fetchDestinationByToken;
    private getExchangeTenant;
    private getAuthTokenForOAuth2ClientCrendentials;
    private usesSystemUser;
    private getAuthTokenForOAuth2UserBasedTokenExchanges;
    /**
     * @internal
     * This method calls the 'find destination by name' endpoint of the destination service using a client credentials grant.
     * For the find by name endpoint, the destination service will take care of OAuth flows and include the token in the destination.
     * @param destinationResult - Result of the getDestinations call for which the exchange flow is triggred
     * @returns Destination containing the auth token.
     */
    private fetchDestinationWithNonUserExchangeFlows;
    private fetchDestinationWithUserExchangeFlows;
    private addProxyConfiguration;
    private selectSubscriberJwt;
    private updateDestinationCache;
    private getProviderDestinationService;
    private getProviderDestinationCache;
    private getSubscriberDestinationService;
    private getSubscriberDestinationCache;
    private isProviderNeeded;
    private isSubscriberNeeded;
    private searchProviderAccountForDestination;
    private searchSubscriberAccountForDestination;
    private addTrustStoreConfiguration;
}
export {};
//# sourceMappingURL=destination-from-service.d.ts.map