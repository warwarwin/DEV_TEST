"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
/**
 * Representation of a cache to transiently store objects locally for faster access.
 * @typeParam T - Type of the cache entries.
 * @internal
 */
class Cache {
    constructor(validityTimeInMs) {
        this.cache = {};
        this.defaultValidityTimeInMs = validityTimeInMs;
    }
    /**
     * Clear all cached items.
     */
    clear() {
        this.cache = {};
    }
    /**
     * Specifies whether an entry with a given key is defined in cache.
     * @param key - The entry's key.
     * @returns A boolean value that indicates whether the entry exists in cache.
     */
    hasKey(key) {
        return this.cache.hasOwnProperty(key);
    }
    /**
     * Getter of cached entries.
     * @param key - The key of the entry to retrieve.
     * @returns The corresponding entry to the provided key if it is still valid, returns `undefined` otherwise.
     */
    get(key) {
        return key && this.hasKey(key) && !isExpired(this.cache[key])
            ? this.cache[key].entry
            : undefined;
    }
    /**
     * Setter of entries in cache.
     * @param key - The entry's key.
     * @param item - The entry to cache.
     */
    set(key, item) {
        var _a;
        if (key) {
            const expires = (_a = item.expires) !== null && _a !== void 0 ? _a : inferExpirationTime(this.defaultValidityTimeInMs);
            this.cache[key] = { entry: item.entry, expires };
        }
    }
}
exports.Cache = Cache;
function isExpired(item) {
    if (item.expires === undefined) {
        return false;
    }
    return item.expires < Date.now();
}
function inferExpirationTime(validityTimeInMs) {
    const now = new Date();
    return validityTimeInMs
        ? now.setMilliseconds(now.getMilliseconds() + validityTimeInMs).valueOf()
        : undefined;
}
//# sourceMappingURL=cache.js.map