"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeAllParameters = exports.shouldHandleCsrfToken = exports.getDefaultHttpRequestOptions = exports.getAxiosConfigWithDefaultsWithoutMethod = exports.getAxiosConfigWithDefaults = exports.defaultTimeoutTarget = exports.executeHttpRequestWithOrigin = exports.executeHttpRequest = exports.buildRequestWithMergedHeadersAndQueryParameters = exports.encodeTypedClientRequest = exports.buildHttpRequestConfigWithOrigin = exports.execute = exports.addDestinationToRequestConfig = exports.buildHttpRequest = void 0;
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const util_1 = require("@sap-cloud-sdk/util");
const axios_1 = __importDefault(require("axios"));
const connectivity_1 = require("@sap-cloud-sdk/connectivity");
const internal_1 = require("@sap-cloud-sdk/connectivity/internal");
const http_client_types_1 = require("./http-client-types");
const http_request_config_1 = require("./http-request-config");
const csrf_token_header_1 = require("./csrf-token-header");
const logger = (0, util_1.createLogger)({
    package: 'http-client',
    messageContext: 'http-client'
});
/**
 * Builds a {@link DestinationHttpRequestConfig} for the given destination.
 * If a destination name (and a JWT) are provided, it will try to resolve the destination.
 * @param destination - A destination or a destination name and a JWT.
 * @returns A {@link DestinationHttpRequestConfig}.
 */
async function buildHttpRequest(destination) {
    const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
    if (!!resolvedDestination.type && resolvedDestination.type !== 'HTTP') {
        throw Error(`The type of the destination '${(0, connectivity_1.toDestinationNameUrl)(destination)}' has to be 'HTTP', but is '${destination.type}'.`);
    }
    const headers = await buildHeaders(resolvedDestination);
    return buildDestinationHttpRequestConfig(resolvedDestination, headers);
}
exports.buildHttpRequest = buildHttpRequest;
/**
 * Builds a {@link DestinationHttpRequestConfig} for the given destination
 * and then merges it into the given request configuration.
 * Setting of the given request configuration take precedence over any destination related configuration.
 * @param destination - A destination or a destination name and a JWT.
 * @param requestConfig - Any object representing an HTTP request.
 * @returns The given request config merged with the config built for the given destination.
 * @internal
 */
async function addDestinationToRequestConfig(destination, requestConfig) {
    const destinationConfig = await buildHttpRequest(destination);
    return merge(destinationConfig, requestConfig);
}
exports.addDestinationToRequestConfig = addDestinationToRequestConfig;
/**
 * Takes as parameter a function that expects an {@link HttpRequest} and returns a Promise of {@link HttpResponse}.
 * Returns a function that takes a destination and a request-config (extends {@link HttpRequestConfig}), builds an {@link HttpRequest} from them, and calls
 * the provided execute function.
 *
 * NOTE: If you simply want to execute a request without passing your own execute function, use {@link executeHttpRequest} instead.
 * @param executeFn - A function that can execute an {@link HttpRequestConfig}.
 * @returns A function expecting destination and a request.
 * @internal
 */
function execute(executeFn) {
    return async function (destination, requestConfig, options) {
        const resolvedDestination = await (0, internal_1.resolveDestination)(destination);
        if (!!resolvedDestination.type && resolvedDestination.type !== 'HTTP') {
            throw Error(`The type of the destination '${(0, connectivity_1.toDestinationNameUrl)(destination)}' has to be 'HTTP', but is '${destination.type}'.`);
        }
        const destinationRequestConfig = await buildHttpRequest(destination);
        logCustomHeadersWarning(requestConfig.headers);
        const request = await buildRequestWithMergedHeadersAndQueryParameters(requestConfig, resolvedDestination, destinationRequestConfig);
        request.headers = await addCsrfTokenToHeader(destination, request, options);
        logRequestInformation(request);
        return executeFn(request);
    };
}
exports.execute = execute;
/**
 * Build an {@link HttpRequestConfigWithOrigin} from a given {@link HttpRequestConfigWithOrigin} or {@link HttpRequestConfig}
 * @param requestConfig - The given {@link HttpRequestConfigWithOrigin} or {@link HttpRequestConfig}
 * @returns The resulting {@link HttpRequestConfigWithOrigin}
 * @internal
 */
function buildHttpRequestConfigWithOrigin(requestConfig) {
    if ((0, http_client_types_1.isHttpRequestConfigWithOrigin)(requestConfig)) {
        return requestConfig;
    }
    return {
        ...requestConfig,
        headers: {
            requestConfig: {},
            ...(requestConfig.headers && { custom: requestConfig.headers })
        },
        params: {
            requestConfig: {},
            ...(requestConfig.params && { custom: requestConfig.params })
        }
    };
}
exports.buildHttpRequestConfigWithOrigin = buildHttpRequestConfigWithOrigin;
/**
 * This method does nothing and is only there to indicated that the call was made by Odata or OpenApi client and encoding is already done on filter and key parameters.
 * @param params - Parameters which are returned
 * @returns The parameters as they are without encoding.
 * @internal
 */
const encodeTypedClientRequest = (params) => params;
exports.encodeTypedClientRequest = encodeTypedClientRequest;
function encodeQueryParameters(options) {
    const { parameterEncoder, parameters, exclude } = options;
    return Object.fromEntries(Object.entries(parameters).map(([key, value]) => exclude.includes(key)
        ? [key, value]
        : [key, value ? parameterEncoder(value) : value]));
}
function isGenericClientDefault(parameterEncoder) {
    return !parameterEncoder;
}
function isTypedClient(parameterEncoder) {
    return parameterEncoder.name === exports.encodeTypedClientRequest.name;
}
function getEncodedParameters(parameters, requestConfig) {
    const { parameterEncoder } = requestConfig;
    if (isGenericClientDefault(parameterEncoder)) {
        return encodeQueryParameters({
            parameters,
            parameterEncoder: exports.encodeAllParameters,
            exclude: ['custom']
        });
    }
    if (isTypedClient(parameterEncoder)) {
        return encodeQueryParameters({
            parameters,
            parameterEncoder: exports.encodeAllParameters,
            exclude: ['custom', 'requestConfig']
        });
    }
    // Custom encoder provided for generic client -> use it for all origins
    return encodeQueryParameters({ parameters, parameterEncoder, exclude: [] });
}
/**
 * @internal
 * Build a request config from a given request config and a destination.
 * In addition to merging the information from the request config and the destination, it also picks values with higher priority for headers and query parameters.
 * @param requestConfig - Any object representing an HTTP request.
 * @param destination - A resolved {@link Destination} object.
 * @param destinationRequestConfig - A {@link DestinationHttpRequestConfig} object, that is built from a {@link Destination}.
 * @see {@link mergeOptionsWithPriority}
 * @returns A resulting request config.
 */
async function buildRequestWithMergedHeadersAndQueryParameters(requestConfig, destination, destinationRequestConfig) {
    const { paramsOriginOptions, headersOriginOptions, requestConfigBase } = splitRequestConfig(requestConfig);
    const parameters = collectParametersFromAllOrigins(destination, paramsOriginOptions);
    const encodedParameters = getEncodedParameters(parameters, requestConfig);
    const mergedQueryParameter = (0, http_request_config_1.mergeOptionsWithPriority)(encodedParameters);
    const mergedHeaders = await getMergedHeaders(destination, headersOriginOptions);
    const request = merge(destinationRequestConfig, requestConfigBase);
    request.headers = mergedHeaders || {};
    request.params = mergedQueryParameter || {};
    return request;
}
exports.buildRequestWithMergedHeadersAndQueryParameters = buildRequestWithMergedHeadersAndQueryParameters;
async function getMergedHeaders(destination, headersOriginOptions) {
    const headersDestination = await buildHeaders(destination);
    const customAuthHeader = (0, internal_1.getAuthHeader)(destination.authentication, headersOriginOptions === null || headersOriginOptions === void 0 ? void 0 : headersOriginOptions.custom);
    const queryParametersDestinationProperty = (0, internal_1.getAdditionalHeaders)(destination.originalProperties || {}).headers;
    return (0, http_request_config_1.mergeOptionsWithPriority)({
        requestConfig: headersOriginOptions === null || headersOriginOptions === void 0 ? void 0 : headersOriginOptions.requestConfig,
        custom: { ...headersOriginOptions === null || headersOriginOptions === void 0 ? void 0 : headersOriginOptions.custom, ...customAuthHeader },
        destinationProperty: queryParametersDestinationProperty,
        destination: headersDestination
    });
}
function collectParametersFromAllOrigins(destination, paramsOriginOptions) {
    const queryParametersDestinationProperty = (0, internal_1.getAdditionalQueryParameters)(destination.originalProperties || {}).queryParameters;
    return {
        ...paramsOriginOptions,
        destinationProperty: queryParametersDestinationProperty,
        destination: destination.queryParameters
    };
}
function splitRequestConfig(requestConfig) {
    const paramsOriginOptions = requestConfig.params;
    const headersOriginOptions = requestConfig.headers;
    return {
        paramsOriginOptions,
        headersOriginOptions,
        requestConfigBase: requestConfig
    };
}
function logCustomHeadersWarning(headers) {
    if (!headers) {
        return;
    }
    const customHeaders = headers.custom;
    const requestConfigHeaders = headers.requestConfig;
    if (customHeaders && requestConfigHeaders) {
        const headerKeysToBeOverwritten = Object.keys(customHeaders).filter(customHeaderKey => Object.keys(requestConfigHeaders).includes(customHeaderKey));
        if (headerKeysToBeOverwritten.length) {
            logger.debug(`The following custom headers will overwrite headers created by the SDK, if they use the same key:\n${headerKeysToBeOverwritten
                .map(key => `  - "${key}"`)
                .join('\n')}
If the parameters from multiple origins use the same key, the priority is 1. Custom, 2. Destination, 3. Internal.`);
        }
    }
}
function logRequestInformation(request) {
    const basicRequestInfo = `Execute '${request.method}' request with target: ${request.url}.`;
    if (request.headers) {
        const headerText = Object.entries((0, util_1.sanitizeRecord)(request.headers))
            .map(([key, value]) => `${key}:${value}`)
            .join(util_1.unixEOL);
        logger.debug(`${basicRequestInfo}${util_1.unixEOL}The headers of the request are:${util_1.unixEOL}${headerText}`);
    }
    else {
        logger.debug(basicRequestInfo);
    }
}
// eslint-disable-next-line jsdoc/require-jsdoc
function executeHttpRequest(destination, requestConfig, options) {
    // eslint-disable-next-line jsdoc/require-jsdoc
    const requestConfigWithOrigin = buildHttpRequestConfigWithOrigin(requestConfig);
    return execute(executeWithAxios)(destination, requestConfigWithOrigin, options);
}
exports.executeHttpRequest = executeHttpRequest;
/**
 * Builds a {@link DestinationHttpRequestConfig} for the given destination, merges it into the given {@link HttpRequestConfigWithOrigin}
 * and executes it (using Axios).
 * The {@link HttpRequestConfigWithOrigin} supports defining header options and query parameter options with origins.
 * Equally named headers and query parameters are prioritized in the following order:
 * 1. `custom`
 * 2. Destination related headers/query parameters
 * 3. `requestConfig`.
 * @param destination - A destination or a destination name and a JWT.
 * @param requestConfig - Any object representing an HTTP request.
 * @param options - An {@link HttpRequestOptions} of the HTTP request for configuring e.g., CSRF token delegation. By default, the SDK will fetch the CSRF token.
 * @returns A promise resolving to an {@link HttpResponse}.
 * @see https://sap.github.io/cloud-sdk/docs/js/features/connectivity/query-parameters
 */
function executeHttpRequestWithOrigin(destination, requestConfig, options) {
    return execute(executeWithAxios)(destination, requestConfig, options);
}
exports.executeHttpRequestWithOrigin = executeHttpRequestWithOrigin;
function buildDestinationHttpRequestConfig(destination, headers) {
    return {
        baseURL: destination.url,
        headers,
        params: destination.queryParameters,
        ...(0, connectivity_1.getAgentConfig)(destination)
    };
}
async function buildHeaders(destination) {
    try {
        return await (0, connectivity_1.buildHeadersForDestination)(destination);
    }
    catch (error) {
        throw new util_1.ErrorWithCause('Failed to build headers.', error);
    }
}
function merge(destinationRequestConfig, customRequestConfig) {
    return {
        ...destinationRequestConfig,
        ...customRequestConfig,
        headers: {
            ...destinationRequestConfig.headers,
            ...customRequestConfig.headers
        }
    };
}
function mergeRequestWithAxiosDefaults(request) {
    return { ...getAxiosConfigWithDefaults(), ...request };
}
function executeWithAxios(request) {
    return axios_1.default.request(mergeRequestWithAxiosDefaults(request));
}
/**
 * @internal
 */
exports.defaultTimeoutTarget = 10000;
/**
 * Builds an Axios config with default configuration i.e. no_proxy, default http and https agent and GET as request method.
 * @returns AxiosRequestConfig with default parameters
 * @internal
 */
function getAxiosConfigWithDefaults() {
    return {
        ...getAxiosConfigWithDefaultsWithoutMethod(),
        method: 'get'
    };
}
exports.getAxiosConfigWithDefaults = getAxiosConfigWithDefaults;
/**
 * @internal
 */
function getAxiosConfigWithDefaultsWithoutMethod() {
    return {
        proxy: false,
        httpAgent: new http.Agent(),
        httpsAgent: new https.Agent(),
        timeout: exports.defaultTimeoutTarget,
        paramsSerializer: (params = {}) => Object.entries(params)
            .map(([key, value]) => `${key}=${value}`)
            .join('&')
    };
}
exports.getAxiosConfigWithDefaultsWithoutMethod = getAxiosConfigWithDefaultsWithoutMethod;
/**
 * @internal
 */
function getDefaultHttpRequestOptions() {
    return {
        fetchCsrfToken: true
    };
}
exports.getDefaultHttpRequestOptions = getDefaultHttpRequestOptions;
function buildHttpRequestOptions(httpRequestOptions) {
    return httpRequestOptions
        ? {
            ...getDefaultHttpRequestOptions(),
            ...httpRequestOptions
        }
        : getDefaultHttpRequestOptions();
}
/**
 * @internal
 */
function shouldHandleCsrfToken(requestConfig, options) {
    return (!!options.fetchCsrfToken &&
        requestConfig.method !== 'get' &&
        requestConfig.method !== 'GET');
}
exports.shouldHandleCsrfToken = shouldHandleCsrfToken;
async function getCsrfHeaders(destination, request) {
    const csrfHeaders = (0, util_1.pickIgnoreCase)(request.headers, 'x-csrf-token');
    return Object.keys(csrfHeaders).length
        ? csrfHeaders
        : (0, csrf_token_header_1.buildCsrfHeaders)(destination, {
            params: request.params,
            headers: request.headers,
            url: request.url,
            timeout: request.timeout || internal_1.defaultResilienceBTPServices.timeout,
            proxy: request.proxy,
            httpAgent: request.httpAgent,
            httpsAgent: request.httpsAgent
        });
}
async function addCsrfTokenToHeader(destination, request, httpRequestOptions) {
    const options = buildHttpRequestOptions(httpRequestOptions);
    const csrfHeaders = shouldHandleCsrfToken(request, options)
        ? await getCsrfHeaders(destination, request)
        : {};
    return { ...request.headers, ...csrfHeaders };
}
/**
 * Encoder for encoding all query parameters (key and value) using encodeURIComponent.
 * @param parameter - Parameter to be encoded using encodeURIComponent.
 * @returns Encoded parameter object.
 */
const encodeAllParameters = function (parameter) {
    return Object.fromEntries(Object.entries(parameter).map(([key, value]) => [
        encodeURIComponent(key),
        encodeURIComponent(value)
    ]));
};
exports.encodeAllParameters = encodeAllParameters;
//# sourceMappingURL=http-client.js.map